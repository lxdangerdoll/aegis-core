#!/usr/bin/env python3
"""
Dynamic Mul        # Scan for .env.* files (excluding .example files)
        for env_file in self.workspace_root.glob(".env.*"):
            if env_file.name.endswith(".example") or env_file.name.endswith("-template"):
                continueot Configuration Generator

This script auto-discovers bot configurations from .env.* files and character JSON files,
then generates Docker Compose configuration and management scripts dynamically.

Usage:
    python scripts/generate_multi_bot_config.py

Requirements:
    - .env.{bot_name} files for bot-specific configuration
    - characters/examples/{character_name}.json files for CDL character definitions
    - Automatic mapping between bot names and character files
"""

import os
import yaml
import re
from pathlib import Path
from typing import Dict, Optional
import argparse

class BotConfigDiscovery:
    """Discovers and manages bot configurations dynamically."""
    
    def __init__(self, workspace_root: str = "."):
        self.workspace_root = Path(workspace_root)
        self.env_pattern = re.compile(r"^\.env\.(.+)$")
        self.character_pattern = re.compile(r"^(.+)\.json$")
        
    def discover_bot_configs(self) -> Dict[str, Dict]:
        """
        Discover all bot configurations by scanning for .env.* files.
        Returns mapping of bot_name -> config_info
        """
        bot_configs = {}
        
        # Scan for .env.* files (excluding .example and .template files)
        for env_file in self.workspace_root.glob(".env.*"):
            if env_file.name.endswith(".example") or env_file.name.endswith(".template"):
                continue
                
            match = self.env_pattern.match(env_file.name)
            if match:
                bot_name = match.group(1)
                
                # Skip template and special files
                if bot_name in ["template", "multi-bot", "bot-template"]:
                    continue
                
                # Find corresponding character file
                character_file = self._find_character_file(bot_name)
                
                # Generate unique ports (9090 + hash of bot_name)
                health_port = 9090 + (hash(bot_name) % 50)
                
                bot_configs[bot_name] = {
                    "env_file": env_file.name,
                    "character_file": character_file,
                    "health_port": health_port,
                    "container_name": f"whisperengine-{bot_name}-bot",
                    "service_name": f"{bot_name}-bot",
                    "display_name": self._format_display_name(bot_name),
                    "volume_prefix": bot_name.replace("-", "_")
                }
                
        return bot_configs
    
    def _find_character_file(self, bot_name: str) -> Optional[str]:
        """
        Find the corresponding character file for a bot.
        Tries multiple naming patterns:
        1. Exact match: {bot_name}.json
        2. Common variations: {bot_name}-{suffix}.json  
        3. Manual mapping for special cases
        """
        characters_dir = self.workspace_root / "characters" / "examples"
        
        if not characters_dir.exists():
            return None
            
        # Try exact match first
        exact_match = characters_dir / f"{bot_name}.json"
        if exact_match.exists():
            return f"characters/examples/{bot_name}.json"
            
        # Try common patterns
        patterns = [
            f"{bot_name}-*.json",
            f"*-{bot_name}.json",
            f"*{bot_name}*.json"
        ]
        
        for pattern in patterns:
            matches = list(characters_dir.glob(pattern))
            if matches:
                # Return the first match relative to workspace root
                return f"characters/examples/{matches[0].name}"
                
        # Manual mapping for special cases
        manual_mapping = {
            "elena": "elena-rodriguez.json",
            "marcus": "marcus-thompson.json", 
            "dream": "dream_of_the_endless.json",
            "gabriel": "gabriel-tether.json"
        }
        
        if bot_name in manual_mapping:
            mapped_file = characters_dir / manual_mapping[bot_name]
            if mapped_file.exists():
                return f"characters/examples/{manual_mapping[bot_name]}"
                
        # Default fallback - use first available character file
        json_files = list(characters_dir.glob("*.json"))
        if json_files:
            print(f"Warning: No specific character file found for '{bot_name}', using default: {json_files[0].name}")
            return f"characters/examples/{json_files[0].name}"
            
        return None
    
    def _format_display_name(self, bot_name: str) -> str:
        """Convert bot_name to display name (e.g., 'marcus-chen' -> 'Marcus Chen')"""
        return bot_name.replace("-", " ").replace("_", " ").title()
    
    def generate_docker_compose(self, bot_configs: Dict[str, Dict]) -> Dict:
        """Generate Docker Compose configuration for discovered bots."""
        
        services = {}
        volumes = {}
        
        # Generate services for each discovered bot
        for _bot_name, config in bot_configs.items():
            service_name = config["service_name"]
            
            # Bot service definition
            services[service_name] = {
                "build": {
                    "context": ".",
                    "dockerfile": "Dockerfile.bundled-models",
                    "target": "production"
                },
                "image": "whisperengine-bot:${VERSION:-latest}",
                "container_name": config["container_name"],
                "restart": "unless-stopped",
                "env_file": [config["env_file"]],
                "environment": [
                    f"DISCORD_BOT_NAME={config['display_name']}",
                    f"CDL_DEFAULT_CHARACTER={config['character_file']}" if config['character_file'] else None,
                    f"CONTAINER_NAME={service_name}",
                    "POSTGRES_HOST=postgres",
                    "REDIS_HOST=redis", 
                    "QDRANT_HOST=qdrant",
                    "MODEL_CACHE_DIR=/app/models",
                    "DISABLE_MODEL_DOWNLOAD=true",
                    "HF_HUB_OFFLINE=false",
                    "TRANSFORMERS_OFFLINE=0",
                    "LOG_LEVEL=${LOG_LEVEL:-INFO}",
                    "DEBUG_MODE=false",
                    "PYTHONUNBUFFERED=1",
                    f"HEALTH_CHECK_PORT={config['health_port']}",
                    "HEALTH_CHECK_HOST=0.0.0.0"
                ],
                "ports": [f"{config['health_port']}:{config['health_port']}"],
                "deploy": {
                    "resources": {
                        "limits": {"memory": "4G", "cpus": "4.0"},
                        "reservations": {"memory": "2G", "cpus": "2.0"}
                    }
                },
                "healthcheck": {
                    "test": [
                        "CMD-SHELL", 
                        f"curl -f http://localhost:{config['health_port']}/health || exit 1"
                    ],
                    "interval": "30s",
                    "timeout": "10s", 
                    "retries": 3,
                    "start_period": "40s"
                },
                "volumes": [
                    f"{config['volume_prefix']}_backups:/app/backups",
                    f"{config['volume_prefix']}_privacy:/app/privacy_data", 
                    f"{config['volume_prefix']}_temp:/app/temp_images",
                    f"{config['volume_prefix']}_logs:/app/logs",
                    "./characters:/app/characters:ro",
                    "./config:/app/config:ro",
                    "shared_models:/app/models:ro"
                ],
                "networks": ["bot_network"],
                "depends_on": {
                    "redis": {"condition": "service_healthy"},
                    "postgres": {"condition": "service_healthy"},
                    "qdrant": {"condition": "service_healthy"}
                }
            }
            
            # Filter out None environment variables
            services[service_name]["environment"] = [
                env for env in services[service_name]["environment"] if env is not None
            ]
            
            # Generate volume definitions
            for volume_type in ["backups", "privacy", "temp", "logs"]:
                volume_name = f"{config['volume_prefix']}_{volume_type}"
                volumes[volume_name] = None  # Use default volume configuration
        
        # Add shared infrastructure and volumes
        services.update(self._get_infrastructure_services())
        volumes.update(self._get_shared_volumes())
        
        return {
            "services": services,
            "volumes": volumes,
            "networks": {"bot_network": {"driver": "bridge"}}
        }
    
    def _get_infrastructure_services(self) -> Dict:
        """Get shared infrastructure services (PostgreSQL, Redis, Qdrant)."""
        return {
            "postgres": {
                "image": "postgres:16-alpine",
                "container_name": "whisperengine-multi-postgres",
                "restart": "unless-stopped",
                "environment": [
                    "POSTGRES_DB=${POSTGRES_DB:-whisperengine}",
                    "POSTGRES_USER=${POSTGRES_USER:-whisperengine}",
                    "POSTGRES_PASSWORD=${POSTGRES_PASSWORD:-whisperengine123}"
                ],
                "ports": ["5433:5432"],
                "volumes": ["postgres_data:/var/lib/postgresql/data"],
                "networks": ["bot_network"],
                "healthcheck": {
                    "test": ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-whisperengine}"],
                    "interval": "10s",
                    "timeout": "5s",
                    "retries": 5
                }
            },
            "redis": {
                "image": "redis:7-alpine",
                "container_name": "whisperengine-multi-redis", 
                "restart": "unless-stopped",
                "ports": ["6380:6379"],
                "volumes": ["redis_data:/data"],
                "networks": ["bot_network"],
                "healthcheck": {
                    "test": ["CMD", "redis-cli", "ping"],
                    "interval": "10s",
                    "timeout": "3s",
                    "retries": 3
                }
            },
            "qdrant": {
                "image": "qdrant/qdrant:v1.15.4",
                "container_name": "whisperengine-multi-qdrant",
                "restart": "unless-stopped",
                "ports": ["6335:6333"],
                "volumes": ["qdrant_data:/qdrant/storage"],
                "networks": ["bot_network"]
            }
        }
    
    def _get_shared_volumes(self) -> Dict:
        """Get shared volume definitions."""
        return {
            "postgres_data": None,
            "redis_data": None,
            "qdrant_data": None,
            "shared_models": None
        }
    
    def generate_management_script(self, bot_configs: Dict[str, Dict]) -> str:
        """Generate the multi-bot management script."""
        
        bot_names = list(bot_configs.keys())
        health_endpoints = []
        
        for _bot_name, config in bot_configs.items():
            health_endpoints.append(
                f'    print_info "{config["display_name"]} Bot: http://localhost:{config["health_port"]}/health"'
            )
        
        script_template = f'''#!/bin/bash

# Auto-Generated Multi-Bot Management Script for WhisperEngine
# This script is automatically generated by scripts/generate_multi_bot_config.py
# Do not edit manually - regenerate using: python scripts/generate_multi_bot_config.py

set -e

COMPOSE_FILE="docker-compose.multi-bot.yml"
PROJECT_NAME="whisperengine-multi"

# Discovered bot configurations
AVAILABLE_BOTS=({" ".join([f'"{name}"' for name in bot_names])})

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

# Function to print colored output
print_status() {{
    echo -e "${{GREEN}}[MULTI-BOT]${{NC}} $1"
}}

print_warning() {{
    echo -e "${{YELLOW}}[WARNING]${{NC}} $1"
}}

print_error() {{
    echo -e "${{RED}}[ERROR]${{NC}} $1"
}}

print_info() {{
    echo -e "${{BLUE}}[INFO]${{NC}} $1"
}}

# Function to check if environment files exist
check_env_files() {{
    local missing_files=()
    
    for bot_name in "${{AVAILABLE_BOTS[@]}}"; do
        if [[ ! -f ".env.$bot_name" ]]; then
            missing_files+=(".env.$bot_name")
        fi
    done
    
    if [[ ${{#missing_files[@]}} -gt 0 ]]; then
        print_warning "Missing environment files: ${{missing_files[*]}}"
        print_info "These files contain bot-specific Discord tokens and configuration"
        print_info "Copy from .env and customize for each bot"
        return 1
    fi
    
    return 0
}}

# Function to get available bots
get_available_bots() {{
    echo "${{AVAILABLE_BOTS[*]}}"
}}

# Function to show status of all containers
show_status() {{
    print_status "Multi-Bot Container Status:"
    echo ""
    
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME ps --format "table {{{{.Name}}}}\\t{{{{.Status}}}}\\t{{{{.Ports}}}}" 2>/dev/null || {{
        print_warning "No containers running"
        return
    }}
    
    echo ""
    print_info "Health Check Endpoints:"
{chr(10).join(health_endpoints)}
    echo ""
    print_info "Infrastructure Services:"
    print_info "PostgreSQL: localhost:5433 (multi-bot)"
    print_info "Redis:      localhost:6380 (multi-bot)"
    print_info "Qdrant:     localhost:6335 (multi-bot)"
}}

# Function to start all bots
start_all() {{
    print_status "Starting all character bots..."
    
    if ! check_env_files; then
        print_error "Cannot start without proper environment files"
        exit 1
    fi
    
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME up -d
    
    sleep 5
    show_status
}}

# Function to start specific bot
start_bot() {{
    local bot_name=$1
    
    if [[ -z "$bot_name" ]]; then
        print_error "Bot name required. Available: $(get_available_bots)"
        exit 1
    fi
    
    # Check if bot name is valid
    local valid_bot=false
    for available_bot in "${{AVAILABLE_BOTS[@]}}"; do
        if [[ "$bot_name" == "$available_bot" ]]; then
            valid_bot=true
            break
        fi
    done
    
    if [[ "$valid_bot" == false ]]; then
        print_error "Unknown bot: $bot_name. Available: $(get_available_bots)"
        exit 1
    fi
    
    if [[ ! -f ".env.$bot_name" ]]; then
        print_error "Missing .env.$bot_name file"
        exit 1
    fi
    
    print_status "Starting $bot_name bot..."
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME up -d "${{bot_name}}-bot" redis postgres qdrant
    
    sleep 3
    show_status
}}

# Function to stop specific bot
stop_bot() {{
    local bot_name=$1
    
    if [[ -z "$bot_name" ]]; then
        print_error "Bot name required. Available: $(get_available_bots)"
        exit 1
    fi
    
    # Check if bot name is valid
    local valid_bot=false
    for available_bot in "${{AVAILABLE_BOTS[@]}}"; do
        if [[ "$bot_name" == "$available_bot" ]]; then
            valid_bot=true
            break
        fi
    done
    
    if [[ "$valid_bot" == false ]]; then
        print_error "Unknown bot: $bot_name. Available: $(get_available_bots)"
        exit 1
    fi
    
    print_status "Stopping $bot_name bot..."
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME stop "${{bot_name}}-bot"
}}

# Function to show logs for specific bot
logs_bot() {{
    local bot_name=$1
    
    if [[ -z "$bot_name" ]]; then
        print_error "Bot name required. Available: $(get_available_bots)"
        exit 1
    fi
    
    # Check if bot name is valid
    local valid_bot=false
    for available_bot in "${{AVAILABLE_BOTS[@]}}"; do
        if [[ "$bot_name" == "$available_bot" ]]; then
            valid_bot=true
            break
        fi
    done
    
    if [[ "$valid_bot" == false ]]; then
        print_error "Unknown bot: $bot_name. Available: $(get_available_bots)"
        exit 1
    fi
    
    print_status "Showing logs for $bot_name bot..."
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME logs -f "${{bot_name}}-bot"
}}

# Function to stop all services
stop_all() {{
    print_status "Stopping all multi-bot services..."
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME down
}}

# Function to clean up (stop and remove everything)
cleanup() {{
    print_status "Cleaning up all multi-bot services and volumes..."
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME down -v --remove-orphans
}}

# Function to rebuild and restart specific bot
rebuild_bot() {{
    local bot_name=$1
    
    if [[ -z "$bot_name" ]]; then
        print_error "Bot name required. Available: $(get_available_bots)"
        exit 1
    fi
    
    print_status "Rebuilding and restarting $bot_name bot..."
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME build "${{bot_name}}-bot"
    docker compose -f $COMPOSE_FILE -p $PROJECT_NAME up -d "${{bot_name}}-bot"
    
    sleep 3
    show_status
}}

# Function to show help
show_help() {{
    echo "Multi-Bot Management Script for WhisperEngine"
    echo ""
    echo "Usage: $0 [COMMAND] [BOT_NAME]"
    echo ""
    echo "Commands:"
    echo "  start [BOT_NAME]    Start specific bot or all bots if no name provided"
    echo "  stop [BOT_NAME]     Stop specific bot or all bots if no name provided"
    echo "  restart [BOT_NAME]  Restart specific bot or all bots if no name provided"
    echo "  logs [BOT_NAME]     Show logs for specific bot"
    echo "  status              Show status of all containers"
    echo "  rebuild [BOT_NAME]  Rebuild and restart specific bot"
    echo "  cleanup             Stop and remove all containers and volumes"
    echo "  list                List available bot configurations"
    echo "  help                Show this help message"
    echo ""
    echo "Available bots: $(get_available_bots)"
    echo ""
    echo "Examples:"
    echo "  $0 start            # Start all bots"
    echo "  $0 start elena      # Start only Elena bot"
    echo "  $0 logs marcus      # Show Marcus bot logs"
    echo "  $0 status           # Show all container status"
}}

# Function to list available bot configurations
list_bots() {{
    print_status "Available bot configurations:"
    echo ""
    
    for bot_name in "${{AVAILABLE_BOTS[@]}}"; do
        if [[ -f ".env.$bot_name" ]]; then
            print_info "✓ $bot_name (configured)"
        else
            print_warning "✗ $bot_name (missing .env.$bot_name)"
        fi
    done
    
    echo ""
    print_info "To add a new bot:"
    print_info "1. Create .env.{{bot_name}} file with Discord token"
    print_info "2. Add character JSON file to characters/examples/"
    print_info "3. Regenerate config: python scripts/generate_multi_bot_config.py"
}}

# Main command handling
case "${{1:-help}}" in
    "start")
        if [[ -n "$2" ]]; then
            start_bot "$2"
        else
            start_all
        fi
        ;;
    "stop")
        if [[ -n "$2" ]]; then
            stop_bot "$2"
        else
            stop_all
        fi
        ;;
    "restart")
        if [[ -n "$2" ]]; then
            stop_bot "$2"
            sleep 2
            start_bot "$2"
        else
            stop_all
            sleep 2
            start_all
        fi
        ;;
    "logs")
        logs_bot "$2"
        ;;
    "status")
        show_status
        ;;
    "rebuild")
        rebuild_bot "$2"
        ;;
    "cleanup")
        cleanup
        ;;
    "list")
        list_bots
        ;;
    "help"|*)
        show_help
        ;;
esac
'''
        
        return script_template

def main():
    parser = argparse.ArgumentParser(description="Generate dynamic multi-bot configuration")
    parser.add_argument("--output-dir", default=".", help="Output directory for generated files")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be generated without writing files")
    args = parser.parse_args()
    
    # Initialize discovery system
    discovery = BotConfigDiscovery(args.output_dir)
    
    # Discover bot configurations
    print("🔍 Discovering bot configurations...")
    bot_configs = discovery.discover_bot_configs()
    
    if not bot_configs:
        print("❌ No bot configurations found. Make sure you have .env.* files for your bots.")
        return 1
    
    print(f"✅ Found {len(bot_configs)} bot configurations:")
    for bot_name, config in bot_configs.items():
        status = "✓" if config['character_file'] else "⚠"
        print(f"  {status} {bot_name}: env={config['env_file']}, character={config['character_file']}, port={config['health_port']}")
    
    if args.dry_run:
        print("\\n📋 Dry run - no files will be written")
        return 0
    
    # Generate Docker Compose configuration
    print("\\n🐳 Generating Docker Compose configuration...")
    compose_config = discovery.generate_docker_compose(bot_configs)
    
    compose_path = Path(args.output_dir) / "docker-compose.multi-bot.yml"
    with open(compose_path, 'w', encoding='utf-8') as f:
        yaml.dump(compose_config, f, default_flow_style=False, sort_keys=False)
    print(f"✅ Generated: {compose_path}")
    
    # Generate management script
    print("🛠 Generating management script...")
    script_content = discovery.generate_management_script(bot_configs)
    
    script_path = Path(args.output_dir) / "multi-bot.sh"
    with open(script_path, 'w', encoding='utf-8') as f:
        f.write(script_content)
    
    # Make script executable
    os.chmod(script_path, 0o755)
    print(f"✅ Generated: {script_path}")
    
    print("\\n🎉 Dynamic multi-bot configuration complete!")
    print("\\nNext steps:")
    print("1. To add a new bot, copy .env.template to .env.{bot_name}")
    print("2. Customize the template with bot-specific values")
    print("3. Ensure corresponding character JSON exists in characters/examples/")
    print("4. Regenerate config: source .venv/bin/activate && python scripts/generate_multi_bot_config.py")
    print("5. Test with: ./multi-bot.sh list")
    print("6. Start bots: ./multi-bot.sh start [bot_name]")
    
    return 0

if __name__ == "__main__":
    exit(main())