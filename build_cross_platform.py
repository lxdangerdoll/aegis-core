#!/usr/bin/env python3
"""
Cross-Platform Build System for WhisperEngine Desktop App
Handles building native executables for macOS, Windows, and Linux.
"""

import argparse
import platform
import shutil
import subprocess
import sys
from pathlib import Path


class CrossPlatformBuilder:
    """Manages cross-platform builds for WhisperEngine"""

    def __init__(self):
        self.project_root = Path(__file__).parent
        self.build_dir = self.project_root / "build"
        self.dist_dir = self.project_root / "dist"
        self.current_platform = platform.system().lower()

        # Platform configurations
        self.platforms = {
            "darwin": {
                "name": "macOS",
                "executable": "WhisperEngine.app",
                "spec_file": "whisperengine-macos.spec",
                "bundle": True,
                "console": False,
                "upx": True,
            },
            "windows": {
                "name": "Windows",
                "executable": "WhisperEngine.exe",
                "spec_file": "whisperengine-windows.spec",
                "bundle": False,
                "console": False,
                "upx": True,
            },
            "linux": {
                "name": "Linux",
                "executable": "WhisperEngine",
                "spec_file": "whisperengine-linux.spec",
                "bundle": False,
                "console": False,
                "upx": False,  # UPX often causes issues on Linux
            },
        }

    def detect_platform(self) -> str:
        """Detect current platform"""
        system = platform.system().lower()
        if system == "darwin":
            return "darwin"
        elif system == "windows":
            return "windows"
        elif system == "linux":
            return "linux"
        else:
            raise ValueError(f"Unsupported platform: {system}")

    def get_common_config(self) -> dict:
        """Get common configuration for all platforms"""
        src_path = self.project_root / "src"
        src_path / "ui"

        return {
            "data_files": [
                # No web UI files needed for native Qt app
            ],
            "hidden_imports": [
                # Core Python modules
                "sqlite3",
                "json",
                "asyncio",
                "logging",
                "webbrowser",
                "threading",
                "signal",
                # UI and system tray
                "pystray",
                "PIL",
                "PIL.Image",
                "PIL.ImageDraw",
                # Application modules (only native UI related)
                "src.ui.system_tray",
                "src.config.adaptive_config",
                "src.database.database_integration",
                "src.optimization.cost_optimizer",
            ],
            "excludes": [
                "tkinter",
                "matplotlib",
                "numpy",
                "pandas",
                "scipy",
                "PIL.ImageTk",
                "PIL.ImageWin",
                "PIL.ImageQt",
                "test_*",
                "tests",
            ],
        }

    def generate_spec_file(self, target_platform: str) -> Path:
        """Generate platform-specific .spec file"""
        config = self.platforms[target_platform]
        common = self.get_common_config()
        spec_path = self.project_root / config["spec_file"]

        # Platform-specific adjustments
        if target_platform == "windows":
            # Windows-specific hidden imports
            common["hidden_imports"].extend(
                [
                    "win32api",
                    "win32gui",
                    "win32con",
                    "pywintypes",
                ]
            )
        elif target_platform == "linux":
            # Linux-specific hidden imports
            common["hidden_imports"].extend(
                [
                    "gi",
                    "gi.repository",
                    "gi.repository.Gtk",
                    "gi.repository.GLib",
                ]
            )

        spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
"""
PyInstaller spec file for WhisperEngine Desktop App - {config["name"]}
Generated by cross-platform build system.
"""

import os
from pathlib import Path

# Application paths
app_path = Path.cwd()
src_path = app_path / "src"
ui_path = src_path / "ui"

block_cipher = None

# Data files (templates, static assets)
data_files = {common["data_files"]!r}

# Hidden imports (modules not automatically detected)
hidden_imports = {common["hidden_imports"]!r}

a = Analysis(
    ['universal_native_app.py'],
    pathex=[str(app_path)],
    binaries=[],
    datas=data_files,
    hiddenimports=hidden_imports,
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes={common["excludes"]!r},
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='{config["executable"].split(".")[0]}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx={str(config["upx"])},
    console={str(config["console"])},
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx={str(config["upx"])},
    upx_exclude=[],
    name='{config["executable"].split(".")[0]}',
)
'''

        # Add macOS-specific bundle configuration
        if target_platform == "darwin":
            spec_content += f"""
app = BUNDLE(
    coll,
    name='{config["executable"]}',
    icon=None,
    bundle_identifier='com.whisperengine.desktop',
    info_plist={{
        'NSHighResolutionCapable': 'True',
        'NSAppleScriptEnabled': False,
        'CFBundleDisplayName': 'WhisperEngine',
        'CFBundleShortVersionString': '2.0.0',
        'CFBundleVersion': '2.0.0',
        'NSHumanReadableCopyright': 'WhisperEngine AI Platform',
        'NSRequiresAquaSystemAppearance': False,
        'LSEnvironment': {{
            'PYTHONPATH': '.',
        }},
    }},
)
"""

        # Write spec file
        with open(spec_path, "w", encoding="utf-8") as f:
            f.write(spec_content)

        return spec_path

    def build_platform(self, target_platform: str, clean: bool = True) -> bool:
        """Build for specific platform"""
        if target_platform not in self.platforms:
            return False

        config = self.platforms[target_platform]

        # Check for cross-compilation
        is_cross_compile = target_platform != self.current_platform
        if is_cross_compile:
            pass


        try:
            # Generate spec file
            spec_file = self.generate_spec_file(target_platform)

            # Prepare build command
            python_exe = sys.executable
            pyinstaller_path = Path(python_exe).parent / "pyinstaller"

            # Use pyinstaller from current Python environment
            if pyinstaller_path.exists():
                cmd = [str(pyinstaller_path)]
            else:
                # Fallback to module execution
                cmd = [python_exe, "-m", "PyInstaller"]

            if clean:
                cmd.append("--clean")
            cmd.extend(["--noconfirm", str(spec_file)])

            # Run PyInstaller
            result = subprocess.run(cmd, cwd=self.project_root, capture_output=True, text=True)

            if result.returncode == 0:
                # Check for output - be more flexible about file locations
                config = self.platforms[target_platform]
                possible_outputs = []

                if target_platform == "darwin":
                    possible_outputs = [
                        self.dist_dir / config["executable"],  # WhisperEngine.app
                    ]
                elif target_platform == "windows":
                    possible_outputs = [
                        self.dist_dir / config["executable"],  # WhisperEngine.exe
                        self.dist_dir
                        / config["executable"].split(".")[0]
                        / config["executable"],  # WhisperEngine/WhisperEngine.exe
                        self.dist_dir
                        / config["executable"].split(".")[0]
                        / config["executable"].split(".")[0],  # WhisperEngine/WhisperEngine
                    ]
                else:  # linux
                    possible_outputs = [
                        self.dist_dir / config["executable"],  # WhisperEngine
                        self.dist_dir
                        / config["executable"]
                        / config["executable"],  # WhisperEngine/WhisperEngine
                    ]

                # Find the actual output
                output_path = None
                for path in possible_outputs:
                    if path.exists():
                        output_path = path
                        break

                if output_path:
                    return True
                else:
                    for path in possible_outputs:
                        pass
                    try:
                        for _item in self.dist_dir.iterdir():
                            pass
                    except:
                        pass
                    return False
            else:
                return False

        except Exception:
            return False

    def build_current_platform(self, clean: bool = True) -> bool:
        """Build for current platform"""
        current = self.detect_platform()
        return self.build_platform(current, clean)

    def build_all_supported(self, clean: bool = True) -> dict[str, bool]:
        """Build for all supported platforms (if possible)"""
        results = {}


        for platform_key in self.platforms:
            if platform_key == self.current_platform:
                results[platform_key] = self.build_platform(platform_key, clean)
            else:
                results[platform_key] = self.build_platform(platform_key, clean)

        return results

    def clean_build_artifacts(self):
        """Clean build artifacts"""

        # Remove build and dist directories
        if self.build_dir.exists():
            shutil.rmtree(self.build_dir)

        if self.dist_dir.exists():
            shutil.rmtree(self.dist_dir)

        # Remove spec files
        for platform_config in self.platforms.values():
            spec_path = self.project_root / platform_config["spec_file"]
            if spec_path.exists():
                spec_path.unlink()


    def get_build_info(self) -> dict:
        """Get build environment information"""
        return {
            "platform": platform.platform(),
            "python_version": platform.python_version(),
            "architecture": platform.architecture(),
            "machine": platform.machine(),
            "processor": platform.processor(),
            "current_platform": self.current_platform,
            "supported_platforms": list(self.platforms.keys()),
        }


def main():
    """Main CLI interface"""
    parser = argparse.ArgumentParser(description="WhisperEngine Cross-Platform Builder")
    parser.add_argument(
        "command", choices=["build", "build-all", "clean", "info"], help="Build command to execute"
    )
    parser.add_argument(
        "--platform",
        choices=["darwin", "windows", "linux"],
        help="Target platform (default: current platform)",
    )
    parser.add_argument(
        "--no-clean", action="store_true", help="Skip cleaning build artifacts before building"
    )

    args = parser.parse_args()

    builder = CrossPlatformBuilder()


    if args.command == "info":
        info = builder.get_build_info()
        for _key, _value in info.items():
            pass

    elif args.command == "clean":
        builder.clean_build_artifacts()

    elif args.command == "build":
        clean = not args.no_clean
        if args.platform:
            success = builder.build_platform(args.platform, clean)
        else:
            success = builder.build_current_platform(clean)

        if success:
            pass
        else:
            sys.exit(1)

    elif args.command == "build-all":
        clean = not args.no_clean
        results = builder.build_all_supported(clean)

        for _platform, success in results.items():
            pass

        if any(results.values()):
            pass
        else:
            sys.exit(1)


if __name__ == "__main__":
    main()
