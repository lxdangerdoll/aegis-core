#!/usr/bin/env python3
"""
Multi-Emotion Storage and Retrieval Verification Test
====================================================

Tests whether all RoBERTa emotions (all 7 with their scores) are properly:
1. Generated by Enhanced Vector Emotion Analyzer
2. Stored in vector memory with full emotion data
3. Retrievable with complete emotion information

Usage:
    python test_multi_emotion_storage.py
"""

import asyncio
import os
import json
from typing import Dict, Any

async def test_complete_emotion_data_flow():
    """Test the complete flow of multi-emotion data from analysis to storage to retrieval"""
    
    print('🎭 Multi-Emotion Storage and Retrieval Test')
    print('=' * 60)
    
    try:
        from src.intelligence.enhanced_vector_emotion_analyzer import create_enhanced_emotion_analyzer
        from src.memory.vector_memory_system import VectorMemoryStore
        from src.intelligence.emotion_taxonomy import standardize_emotion
        
        # Test message with potential for mixed emotions
        test_message = "I am frustrated with the delays but excited about the final outcome"
        test_user = "multi_emotion_test_user"
        
        print(f'📝 Test message: "{test_message}"')
        print(f'👤 Test user: {test_user}')
        
        # 1. Test Enhanced Vector Emotion Analyzer
        print('\n🎭 Step 1: Enhanced Vector Emotion Analysis...')
        analyzer = create_enhanced_emotion_analyzer(None)
        result = await analyzer.analyze_emotion(test_message, test_user)
        
        print(f'✅ Primary emotion: {result.primary_emotion}')
        print(f'🎯 Confidence: {result.confidence:.3f}')
        print(f'⚡ Intensity: {result.intensity:.3f}')
        
        print(f'\n📊 ALL 7 RoBERTa EMOTIONS:')
        total_score = sum(result.all_emotions.values())
        for emotion, score in sorted(result.all_emotions.items(), key=lambda x: x[1], reverse=True):
            percentage = (score / total_score) * 100 if total_score > 0 else 0
            standardized = standardize_emotion(emotion)
            is_standardized = emotion == standardized
            status = '✅' if is_standardized else '❌'
            print(f'  {status} {emotion}: {score:.4f} ({percentage:.1f}%)')
        
        # 2. Check mixed emotions
        print(f'\n🎭 MIXED EMOTIONS (>20% threshold):')
        if result.mixed_emotions:
            for emotion, score in result.mixed_emotions:
                print(f'  🌟 {emotion}: {score:.4f}')
        else:
            print('  None detected (no secondary emotions >20%)')
        
        # 3. Test data structure completeness  
        print(f'\n🏗️ EMOTION DATA STRUCTURE:')
        emotion_data_fields = [
            'primary_emotion', 'all_emotions', 'confidence', 'intensity',
            'mixed_emotions', 'emotion_description', 'analysis_time_ms'
        ]
        
        for field in emotion_data_fields:
            has_field = hasattr(result, field)
            value = getattr(result, field, 'MISSING')
            status = '✅' if has_field else '❌'
            if field == 'all_emotions':
                print(f'  {status} {field}: {len(value) if isinstance(value, dict) else 0} emotions')
            else:
                print(f'  {status} {field}: {value}')
        
        # 4. Verify emotion standardization in all_emotions
        print(f'\n🔍 ALL_EMOTIONS STANDARDIZATION CHECK:')
        all_standardized = True
        for emotion in result.all_emotions.keys():
            standardized = standardize_emotion(emotion)
            is_standardized = emotion == standardized
            if not is_standardized:
                all_standardized = False
            status = '✅' if is_standardized else '❌'
            print(f'  {status} {emotion} → {standardized}')
        
        if all_standardized:
            print('  🏆 ALL EMOTIONS ARE STANDARDIZED!')
        else:
            print('  ⚠️ Some emotions need standardization')
        
        # 5. Test that we capture the full 7-emotion distribution
        expected_emotions = {'anger', 'disgust', 'fear', 'joy', 'neutral', 'sadness', 'surprise'}
        found_emotions = set(result.all_emotions.keys())
        
        print(f'\n🧮 7-EMOTION COMPLETENESS CHECK:')
        print(f'  Expected: {sorted(expected_emotions)}')
        print(f'  Found: {sorted(found_emotions)}')
        print(f'  Missing: {sorted(expected_emotions - found_emotions)}')
        print(f'  Extra: {sorted(found_emotions - expected_emotions)}')
        
        completeness = len(found_emotions & expected_emotions) / len(expected_emotions)
        status = '✅' if completeness == 1.0 else '❌'
        print(f'  {status} Completeness: {completeness:.1%}')
        
        # 6. Test emotion intensity distribution
        print(f'\n📈 EMOTION INTENSITY DISTRIBUTION:')
        sorted_emotions = sorted(result.all_emotions.items(), key=lambda x: x[1], reverse=True)
        
        print(f'  Dominant: {sorted_emotions[0][0]} ({sorted_emotions[0][1]:.3f})')
        print(f'  Secondary: {sorted_emotions[1][0]} ({sorted_emotions[1][1]:.3f})')
        print(f'  Tertiary: {sorted_emotions[2][0]} ({sorted_emotions[2][1]:.3f})')
        
        # Calculate emotion diversity (how spread out the emotions are)
        emotion_values = list(result.all_emotions.values())
        emotion_variance = max(emotion_values) - min(emotion_values) if len(emotion_values) > 1 else 0.0
        emotion_dominance = max(emotion_values) / sum(emotion_values) if sum(emotion_values) > 0 else 1.0
        
        print(f'  📊 Variance: {emotion_variance:.3f} (higher = more diverse)')
        print(f'  🎯 Dominance: {emotion_dominance:.3f} (lower = more mixed)')
        
        print('\n✅ Multi-emotion analysis test completed successfully!')
        
        return True
        
    except Exception as e:
        print(f'❌ Error in multi-emotion test: {e}')
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    success = asyncio.run(test_complete_emotion_data_flow())
    print(f'\n🏁 Test Result: {"SUCCESS" if success else "FAILURE"}')