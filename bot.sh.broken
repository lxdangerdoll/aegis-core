#!/bin/bash

# =============================================================================
# WhisperEngine Unified Bot Management Script
# =============================================================================
# Multi-Bot Architecture: Start with 1 bot, scale to N bots
# Shared infrastructure: PostgreSQL, Redis, Qdrant
# Simple commands: ./bot.sh start, ./bot.sh stop, ./bot.sh logs

set -euo pipefail  # Exit on any error, undefined variables, pipe failures
IFS=$'\n\t'       # Secure Internal Field Separator

# Cleanup function
cleanup() {

    local exit_code=$?

# Cleanup function    if [[ $exit_code -ne 0 ]]; then

cleanup() {        print_warning "Script interrupted. Cleaning up..."

    local exit_code=$?        # Kill any background processes if they exist

    if [[ $exit_code -ne 0 ]]; then        jobs -p | xargs -r kill 2>/dev/null || true

        print_warning "Script interrupted. Cleaning up..."    fi

        jobs -p | xargs -r kill 2>/dev/null || true    exit $exit_code

    fi}

    exit $exit_code

}# Set up signal handlers

trap cleanup EXIT

trap cleanup EXITtrap 'cleanup' INT TERM

trap 'cleanup' INT TERM

# Colors

# ColorsGREEN='\033[0;32m'

GREEN='\033[0;32m'YELLOW='\033[1;33m'

YELLOW='\033[1;33m'RED='\033[0;31m'

RED='\033[0;31m'BLUE='\033[0;34m'

BLUE='\033[0;34m'NC='\033[0m'

NC='\033[0m'

# Helper functions

# Helper functionsprint_status() { echo -e "${GREEN}‚úÖ $1${NC}"; }

print_status() { echo -e "${GREEN}‚úÖ $1${NC}"; }print_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }

print_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }print_error() { echo -e "${RED}‚ùå $1${NC}"; }

print_error() { echo -e "${RED}‚ùå $1${NC}"; }

print_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }check_docker() {

    if ! docker info >/dev/null 2>&1; then

# Configuration        print_error "Docker not running. Please start Docker first."

PROJECT_NAME="whisperengine"        exit 1

COMPOSE_FILE="docker-compose.yml"    fi

    

# Available bots configuration    # Check Docker Compose availability (v1 or v2)

declare -A BOT_CONFIGS=(    local compose_cmd=""

    ["elena"]="Elena Rodriguez - Marine Biologist|.env.elena|elena-rodriguez.json|9091"    if command -v docker-compose &> /dev/null; then

    ["marcus"]="Marcus Thompson - AI Researcher|.env.marcus|marcus-thompson.json|9092"        compose_cmd="docker-compose"

    ["marcus-chen"]="Marcus Chen - Indie Game Developer|.env.marcus-chen|marcus-chen.json|9093"    elif docker compose version &> /dev/null; then

    ["dream"]="Dream of the Endless|.env.dream|dream_of_the_endless.json|9094"        compose_cmd="docker compose"

)        export COMPOSE_SUBCMD="compose"

    else

check_docker() {        print_error "Docker Compose is not installed."

    if ! docker info >/dev/null 2>&1; then        echo "Install Docker Compose: https://docs.docker.com/compose/install/"

        print_error "Docker not running. Please start Docker first."        exit 1

        exit 1    fi

    fi    

        # Export compose command for use in other functions

    if docker compose version &> /dev/null; then    export COMPOSE_CMD="$compose_cmd"

        export COMPOSE_CMD="docker compose"    

    elif command -v docker-compose &> /dev/null; then    # Check Docker Compose version for compatibility

        export COMPOSE_CMD="docker-compose"    local compose_version=$($compose_cmd version --short 2>/dev/null | head -1 | cut -d'.' -f1-2)

    else    if [[ -n "$compose_version" ]]; then

        print_error "Docker Compose is not installed."        print_status "Using $compose_cmd (version $compose_version)"

        exit 1    fi

    fi}

    

    print_status "Using $COMPOSE_CMD ($(docker compose version 2>/dev/null || docker-compose --version))"check_env() {

}    if [ ! -f ".env" ]; then

        print_error "No .env file found!"

show_help() {        echo "üìù Copy .env.example to .env and configure:"

    echo "WhisperEngine Unified Bot Management"        echo "   cp .env.example .env"

    echo ""        exit 1

    echo "ü§ñ Multi-Bot Architecture: Start with 1 bot, scale to many"    fi

    echo "   Shared infrastructure: PostgreSQL, Redis, Qdrant"    

    echo "   Each bot gets its own Discord token and character"    # Basic .env validation

    echo ""    if [[ ! -r ".env" ]]; then

    echo "Usage: $0 <command> [options]"        print_error ".env file is not readable"

    echo ""        exit 1

    echo "üöÄ Quick Start:"    fi

    echo "  $0 start elena          # Start Elena bot only"    

    echo "  $0 start all            # Start all configured bots"    # Check for critical variables (without sourcing the file)

    echo "  $0 start infrastructure # Start databases only (for native development)"    local missing_vars=()

    echo ""    

    echo "Commands:"    if ! grep -q "^DISCORD_BOT_TOKEN=" ".env" 2>/dev/null; then

    echo "  start <bot|all|infrastructure>  - Start specific bot(s) or infrastructure"        missing_vars+=("DISCORD_BOT_TOKEN")

    echo "  stop [bot]                      - Stop specific bot or all bots"    fi

    echo "  restart <bot|all>               - Restart specific bot(s)"    

    echo "  status                          - Show all container status"    if ! grep -q "^LLM_CHAT_API_URL=" ".env" 2>/dev/null; then

    echo "  logs [bot]                      - View logs (default: all bots)"        missing_vars+=("LLM_CHAT_API_URL")

    echo "  build [--no-cache]              - Build bot images"    fi

    echo ""    

    echo "Available Bots:"    if [[ ${#missing_vars[@]} -gt 0 ]]; then

    for bot in "${!BOT_CONFIGS[@]}"; do        print_warning "Missing critical environment variables in .env:"

        IFS='|' read -r desc env_file char_file port <<< "${BOT_CONFIGS[$bot]}"        for var in "${missing_vars[@]}"; do

        echo "  $bot    - $desc (port $port)"            echo "  ‚Ä¢ $var"

    done        done

    echo ""        echo ""

    echo "Infrastructure Services:"        echo "Please configure these variables in .env before starting the bot."

    echo "  PostgreSQL: localhost:5433"    fi

    echo "  Redis:      localhost:6380"}

    echo "  Qdrant:     localhost:6335"

    echo ""show_help() {

    echo "Examples:"    echo "Discord Bot Management Script"

    echo "  $0 start elena          # Start just Elena"    echo ""

    echo "  $0 start elena marcus   # Start Elena and Marcus"    echo "üöÄ For Development: Choose your preferred development style!"

    echo "  $0 stop elena           # Stop just Elena"    echo "   Containerized Development:  ./bot.sh start dev   # Hot-reload, mounted code"

    echo "  $0 logs elena           # View Elena's logs"    echo "   Native Development:         python run.py        # After starting infrastructure"

    echo "  $0 status               # Check all services"    echo "   Desktop App:                python universal_native_app.py"

}    echo ""

    echo "üöÄ New to WhisperEngine? Try our cross-platform quick-start scripts:"

check_env_files() {    echo "   Linux/macOS:   curl -sSL https://raw.githubusercontent.com/WhisperEngine-AI/whisperengine/main/scripts/quick-start.sh | bash"

    local bots_to_check=("$@")    echo "   Windows (PS):  iwr https://raw.githubusercontent.com/WhisperEngine-AI/whisperengine/main/scripts/quick-start.ps1 | iex"

    local missing_files=()    echo "   Windows (CMD): Download and run scripts/quick-start.bat"

        echo ""

    if [[ ${#bots_to_check[@]} -eq 0 ]]; then    echo "Usage: $0 <command> [mode]"

        # Check all bot env files    echo ""

        bots_to_check=("${!BOT_CONFIGS[@]}")    echo "Commands:"

    fi    echo "  start [prod|dev|infrastructure]  - Start services (mode required)"

        echo "  stop [prod|dev|infrastructure]   - Stop services"

    for bot in "${bots_to_check[@]}"; do    echo "  logs [service]                   - View logs (default: whisperengine-bot)"

        if [[ ! -v BOT_CONFIGS[$bot] ]]; then    echo "  status                           - Show container status"

            print_warning "Unknown bot: $bot"    echo ""

            continue    echo "Data Import:"

        fi    echo "  import-chatgpt <file> <user-id> [options]  - Import ChatGPT conversations"

            echo ""

        IFS='|' read -r desc env_file char_file port <<< "${BOT_CONFIGS[$bot]}"    echo "Restart Commands (Data Preservation):"

            echo "  restart [prod|dev|infrastructure]     - Restart services"

        if [[ ! -f "$env_file" ]]; then    echo "  restart-all [prod|dev|infrastructure] - Restart all services, PRESERVE data"

            missing_files+=("$env_file")    echo "  restart-full [prod|dev|infrastructure] - Alias for restart-all (preserve data)"

        fi    echo "  restart-clean [prod|dev|infrastructure] - Restart all services, CLEAR cache only"

    done    echo ""

        echo "Data Management:"

    if [[ ${#missing_files[@]} -gt 0 ]]; then    echo "  clear-cache [prod|dev|infrastructure] - Clear Redis cache, keep persistent data"

        print_warning "Missing environment files: ${missing_files[*]}"    echo "  reset-data [prod|dev|infrastructure]  - ‚ö†Ô∏è  DANGER: Clear ALL data volumes"

        print_info "These files contain bot-specific Discord tokens and configuration"    echo "  cleanup                                - Remove orphaned containers and volumes"

        print_info "Copy from .env.template and customize for each bot"    echo "  backup <create|list|restore|help>      - Data backup operations"

        return 1    echo ""

    fi    echo "Development:"

        echo "  build-push [options]     - Build and push Docker image to Docker Hub"

    return 0    echo ""

}    echo "Modes:"

    echo "  prod           - Full production deployment (Discord bot + all services in containers)"

show_status() {    echo "  dev            - Full development deployment with hot-reload and mounted source code"

    print_status "WhisperEngine Bot Status:"    echo "  infrastructure - Infrastructure services only (for developers running bot natively)"

    echo ""    echo ""

        echo ""

    $COMPOSE_CMD ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || {    echo "Examples:"

        print_warning "No containers running"    echo "  $0 start prod                     # Full production deployment"

        return    echo "  $0 start dev                      # Development with hot-reload (recommended for dev)"

    }    echo "  $0 start infrastructure           # Start databases only (for native Python development)"

        echo "  $0 import-chatgpt conversations.json 672814231002939413  # Import ChatGPT history"

    echo ""    echo "  $0 restart dev                    # Restart development services with code changes"

    print_info "Health Check Endpoints:"    echo "  $0 restart-all dev                # Restart all dev services, preserve data"

    for bot in "${!BOT_CONFIGS[@]}"; do    echo "  $0 restart-clean dev              # Restart all, clear cache only"

        IFS='|' read -r desc env_file char_file port <<< "${BOT_CONFIGS[$bot]}"    echo "  $0 clear-cache dev                # Clear cache without restarting"

        echo "  $desc: http://localhost:$port/health"    echo "  $0 logs                           # View bot logs (auto-detects mode)"

    done    echo "  $0 logs redis                     # View redis logs"

        echo "  $0 stop                           # Stop (auto-detects mode)"

    echo ""    echo "  $0 cleanup                        # Clean orphaned containers"

    print_info "Infrastructure Services:"    echo ""

    print_info "  PostgreSQL: localhost:5433"    echo "üí° Development Mode Benefits (dev):"

    print_info "  Redis:      localhost:6380"    echo "   ‚Ä¢ üîÑ Hot-reload: Code changes automatically restart the bot"

    print_info "  Qdrant:     localhost:6335 (HTTP) / 6336 (gRPC)"    echo "   ‚Ä¢ üìÅ Local mounts: /src, /prompts, /config directories mounted from host"

}    echo "   ‚Ä¢ üêõ Debug logging: Detailed logs and error information"

    echo "   ‚Ä¢ üè• Health checks: Monitor bot status during development"

start_infrastructure() {    echo "   ‚Ä¢ üöÄ Full stack: All services running in containers for consistency"

    print_status "Starting shared infrastructure..."    echo ""

    print_info "  PostgreSQL (persistent data)"    echo "üí° Data Persistence Guide:"

    print_info "  Redis (caching)"    echo "   ‚Ä¢ restart         ‚Üí Bot only, everything preserved"

    print_info "  Qdrant (vector storage)"    echo "   ‚Ä¢ restart-all     ‚Üí All services, data preserved" 

        echo "   ‚Ä¢ restart-clean   ‚Üí All services, cache cleared, memories kept"

    $COMPOSE_CMD up -d postgres redis qdrant    echo "   ‚Ä¢ reset-data      ‚Üí ‚ö†Ô∏è  Nuclear option: ALL data destroyed"

        echo ""

    print_status "Infrastructure started! Ready for native bot development."    echo "üí° Backup & Build Commands:"

    print_info "Run 'python run.py' to start a bot natively with this infrastructure."    echo "  $0 backup create        # Create data backup"

}    echo "  $0 backup list          # List available backups"

    echo "  $0 build-push --help    # Show Docker build options"

start_bots() {    echo "  $0 build-push v1.0.0    # Build and push specific version"

    local bots_to_start=("$@")}

    

    if [[ "${bots_to_start[0]}" == "all" ]]; then# Helper function to wait for services using health checks

        bots_to_start=("${!BOT_CONFIGS[@]}")wait_for_services() {

        print_status "Starting all character bots..."    local compose_files="$1"

    else    local max_attempts=60

        print_status "Starting bots: ${bots_to_start[*]}"    local attempt=0

    fi    

        echo "‚è≥ Waiting for all services to be healthy..."

    # Validate bot names    echo "üìä Services: PostgreSQL, Redis, Qdrant, Bot"

    for bot in "${bots_to_start[@]}"; do    

        if [[ ! -v BOT_CONFIGS[$bot] ]]; then    while [[ $attempt -lt $max_attempts ]]; do

            print_error "Unknown bot: $bot"        local healthy_count=0

            print_info "Available bots: ${!BOT_CONFIGS[*]}"        local status_line=""

            exit 1        

        fi        # Check infrastructure services health

    done        if $COMPOSE_CMD $compose_files ps postgres | grep -q "healthy"; then 

                ((healthy_count++))

    if ! check_env_files "${bots_to_start[@]}"; then            status_line+="‚úÖDB "

        print_error "Cannot start without proper environment files"        else

        exit 1            status_line+="‚è≥DB "

    fi        fi

            

    # Start infrastructure first        if $COMPOSE_CMD $compose_files ps redis | grep -q "healthy"; then 

    $COMPOSE_CMD up -d postgres redis qdrant            ((healthy_count++))

                status_line+="‚úÖRedis "

    # Start requested bots        else

    local services_to_start=()            status_line+="‚è≥Redis "

    for bot in "${bots_to_start[@]}"; do        fi

        services_to_start+=("${bot}-bot")        

    done        if $COMPOSE_CMD $compose_files ps qdrant | grep -q "healthy"; then 

                ((healthy_count++))

    $COMPOSE_CMD up -d "${services_to_start[@]}"            status_line+="‚úÖVector "

            else

    echo ""            status_line+="‚è≥Vector "

    print_status "Bots starting up..."        fi

            

    echo ""        # Check bot health using our new health endpoint

    print_info "Health Check Endpoints:"        if curl -sf http://localhost:9090/health >/dev/null 2>&1; then

    for bot in "${bots_to_start[@]}"; do            ((healthy_count++))

        IFS='|' read -r desc env_file char_file port <<< "${BOT_CONFIGS[$bot]}"            status_line+="‚úÖBot"

        print_info "  $desc: http://localhost:$port/health"        else

    done            status_line+="‚è≥Bot"

}        fi

        

stop_bots() {        # Clear previous line and show current status

    local bots_to_stop=("$@")        echo -ne "\r$status_line (${healthy_count}/5)"

            

    if [[ ${#bots_to_stop[@]} -eq 0 ]]; then        if [[ $healthy_count -eq 5 ]]; then

        print_status "Stopping all services..."            echo ""

        $COMPOSE_CMD down            return 0

    else        fi

        print_status "Stopping bots: ${bots_to_stop[*]}"        

                sleep 2

        local services_to_stop=()        ((attempt++))

        for bot in "${bots_to_stop[@]}"; do    done

            if [[ -v BOT_CONFIGS[$bot] ]]; then    

                services_to_stop+=("${bot}-bot")    echo ""

            else    print_warning "Some services may still be starting. Use '$0 status' to check."

                print_warning "Unknown bot: $bot"    return 1

            fi}

        done

        start_bot() {

        if [[ ${#services_to_stop[@]} -gt 0 ]]; then    local mode="$1"

            $COMPOSE_CMD stop "${services_to_stop[@]}"    

        fi    # Require explicit mode selection

    fi    if [[ -z "$mode" ]]; then

}        print_error "Mode is required. Please specify: prod, dev, or infrastructure"

        echo ""

restart_bots() {        echo "Usage: $0 start <mode>"

    local bots_to_restart=("$@")        echo "  prod           - Full production deployment (Discord bot + all services)"

            echo "  dev            - Full development deployment with hot-reload and mounted code"

    if [[ "${bots_to_restart[0]}" == "all" ]]; then        echo "  infrastructure - Infrastructure services only (for native bot development)" 

        print_status "Restarting all bots..."        echo ""

        $COMPOSE_CMD restart        echo "üí° For development, we recommend: $0 start dev (for containerized development with hot-reload)"

    else        echo "üí° Or: python run.py (after starting infrastructure for native development)"

        print_status "Restarting bots: ${bots_to_restart[*]}"        exit 1

            fi

        local services_to_restart=()    

        for bot in "${bots_to_restart[@]}"; do    check_docker

            if [[ -v BOT_CONFIGS[$bot] ]]; then    check_env

                services_to_restart+=("${bot}-bot")    

            else    # Validate compose files exist

                print_warning "Unknown bot: $bot"    case $mode in

            fi        "prod")

        done            if [[ ! -f "docker-compose.yml" ]] || [[ ! -f "docker-compose.prod.yml" ]]; then

                        print_error "Required compose files not found (docker-compose.yml and docker-compose.prod.yml)"

        if [[ ${#services_to_restart[@]} -gt 0 ]]; then                exit 1

            $COMPOSE_CMD restart "${services_to_restart[@]}"            fi

        fi            ;;

    fi        "dev")

}            if [[ ! -f "docker-compose.yml" ]] || [[ ! -f "docker-compose.dev.yml" ]]; then

                print_error "Required compose files not found (docker-compose.yml and docker-compose.dev.yml)"

view_logs() {                exit 1

    local bots_to_log=("$@")            fi

                ;;

    if [[ ${#bots_to_log[@]} -eq 0 ]]; then        "infrastructure")

        print_status "Viewing logs for all services..."            if [[ ! -f "docker-compose.yml" ]]; then

        $COMPOSE_CMD logs -f                print_error "docker-compose.yml not found"

    else                exit 1

        print_status "Viewing logs for: ${bots_to_log[*]}"            fi

                    ;;

        local services_to_log=()        *)

        for bot in "${bots_to_log[@]}"; do            print_error "Invalid mode: $mode"

            if [[ -v BOT_CONFIGS[$bot] ]]; then            echo "Valid modes: prod, dev, infrastructure"

                services_to_log+=("${bot}-bot")            exit 1

            else            ;;

                print_warning "Unknown bot: $bot"    esac

            fi    

        done    case $mode in

                "prod")

        if [[ ${#services_to_log[@]} -gt 0 ]]; then            echo "üöÄ Starting Discord Bot in Production Mode..."

            $COMPOSE_CMD logs -f "${services_to_log[@]}"            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml up -d --build

        fi            

    fi            # Use improved health check waiting

}            if wait_for_services "-f docker-compose.yml -f docker-compose.prod.yml"; then

                print_status "Bot started in production mode with all services healthy!"

build_images() {                echo ""

    local build_args=("$@")                echo "üè• Health Check: http://localhost:9090/health"

                    echo "üìä Bot Status: http://localhost:9090/status" 

    print_status "Building bot images..."            else

                    print_warning "Some services may still be initializing"

    if [[ " ${build_args[*]} " =~ " --no-cache " ]]; then            fi

        $COMPOSE_CMD build --no-cache            

    else            echo ""

        $COMPOSE_CMD build            echo "üìã Quick Commands:"

    fi            echo "   $0 logs        # View logs"

                echo "   $0 stop        # Stop bot"

    print_status "Build complete!"            echo "   $0 status      # Check status"

}            ;;

        "dev")

# Main command processing            echo "üöÄ Starting Discord Bot in Development Mode with Hot-Reload..."

main() {            echo "   üîÑ Code changes will automatically reload"

    if [[ $# -eq 0 ]]; then            echo "   üìÅ Local prompts and config mounted"

        show_help            echo "   üêõ Debug mode enabled with detailed logging"

        exit 0            

    fi            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml up -d --build

                

    check_docker            # Use improved health check waiting

                if wait_for_services "-f docker-compose.yml -f docker-compose.dev.yml"; then

    local command="$1"                print_status "Bot started in development mode with all services healthy!"

    shift                echo ""

                    echo "üè• Health Check: http://localhost:9090/health"

    case "$command" in                echo "üìä Bot Status: http://localhost:9090/status" 

        "start")                echo "üîÑ Hot-reload: Code changes will automatically restart the bot"

            if [[ $# -eq 0 ]]; then            else

                print_error "Please specify what to start: <bot-name>, 'all', or 'infrastructure'"                print_warning "Some services may still be initializing"

                print_info "Example: $0 start elena"            fi

                exit 1            

            fi            echo ""

                        echo "üìã Development Features:"

            if [[ "$1" == "infrastructure" ]]; then            echo "   ‚Ä¢ Hot-reload: Edit code and see changes instantly"

                start_infrastructure            echo "   ‚Ä¢ Debug logging: Detailed logs for troubleshooting"

            else            echo "   ‚Ä¢ Local mounts: /src, /prompts, /config directories mounted"

                start_bots "$@"            echo "   ‚Ä¢ Health endpoints: Monitor bot status during development"

            fi            echo ""

            ;;            echo "üìã Quick Commands:"

        "stop")            echo "   $0 logs        # View detailed debug logs"

            stop_bots "$@"            echo "   $0 stop        # Stop development environment"

            ;;            echo "   $0 status      # Check service health"

        "restart")            echo "   $0 restart dev # Restart with code changes"

            if [[ $# -eq 0 ]]; then            ;;

                print_error "Please specify what to restart: <bot-name> or 'all'"        "infrastructure")

                exit 1            echo "üöÄ Starting infrastructure services for native development..."

            fi            

            restart_bots "$@"            # Start all 3 core datastores (all required for native development)

            ;;            echo "üîÑ Starting all core datastore services..."

        "status")            echo "   üìä PostgreSQL (persistent data)"

            show_status            echo "   üî¥ Redis (caching)"  

            ;;            echo "   üóÉÔ∏è Qdrant (vector storage)"

        "logs")            

            view_logs "$@"            # Use --remove-orphans to clean up any leftover containers from previous configurations

            ;;            $COMPOSE_CMD up -d --remove-orphans postgres redis qdrant

        "build")            

            build_images "$@"            echo "‚è≥ Waiting for all services to initialize..."

            ;;            

        "help"|"-h"|"--help")            # Wait for all services to be healthy with proper status checking

            show_help            local max_attempts=30

            ;;            local attempt=0

        *)            local services_ready=0

            print_error "Unknown command: $command"            

            show_help            while [[ $attempt -lt $max_attempts && $services_ready -lt 3 ]]; do

            exit 1                services_ready=0

            ;;                

    esac                # Check each service individually (only count once per loop)

}                if $COMPOSE_CMD ps postgres | grep -q "healthy"; then ((services_ready++)); fi

                if $COMPOSE_CMD ps redis | grep -q "healthy"; then ((services_ready++)); fi

main "$@"                if $COMPOSE_CMD ps qdrant | grep -q "healthy"; then ((services_ready++)); fi
                
                if [[ $services_ready -eq 3 ]]; then
                    echo "   ‚úÖ All services ready!"
                    break
                fi
                
                echo "   ‚è≥ Services ready: $services_ready/3 (attempt $((attempt+1))/$max_attempts)"
                sleep 3
                ((attempt++))
            done
            
            if [[ $services_ready -eq 3 ]]; then
                print_status "All 3 datastores are healthy and ready!"
                echo "   üìä PostgreSQL: localhost:5432"
                echo "   üî¥ Redis: localhost:6379"
                echo "   üóÉÔ∏è Qdrant: localhost:6333"
            else
                print_warning "Some services may still be starting. Run '$0 status' to check."
            fi
            
            # Python dependency checks (optional for infrastructure-only mode)
            # Only check if Python is available - don't force installation
            if command -v python &> /dev/null || command -v python3 &> /dev/null; then
                # Use python3 if python command doesn't exist
                local python_cmd="python"
                if ! command -v python &> /dev/null; then
                    python_cmd="python3"
                fi
                
                # Check Python version
                local python_version=$($python_cmd -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null || echo "unknown")
                if [[ "$python_version" != "unknown" ]] && [[ $(echo "$python_version < 3.13" | bc -l 2>/dev/null || echo "1") -eq 1 ]]; then
                    print_warning "Python $python_version detected. Python 3.13+ recommended for native development."
                fi
                
                # REMOVED: spaCy check (spaCy superseded by vector-native memory system)
                # Previous: if ! $python_cmd -c "import spacy; spacy.load('en_core_web_sm')" &>/dev/null 2>&1; then
                #     echo "‚ÑπÔ∏è  Note: spaCy model not found (only needed for native development)"
                # fi
                
                # Check for required packages
                if ! $python_cmd -c "import discord, asyncio" &>/dev/null 2>&1; then
                    echo "‚ÑπÔ∏è  Note: Some Python dependencies not found (only needed for native development)"
                    echo "   If you plan to run the bot natively, install with:"
                    echo "   $python_cmd -m pip install -r requirements-core.txt"
                    echo "   $python_cmd -m pip install -r requirements-platform.txt"
                    echo "   $python_cmd -m pip install -r requirements-discord.txt"
                    echo "   Or use: ./scripts/install-discord.sh"
                fi
            else
                echo "‚ÑπÔ∏è  Note: Python not found (only needed for native development)"
            fi
            
            print_status "Infrastructure ready!"
            echo ""
            echo "üí° Next steps:"
            echo "   # For Docker development:"
            echo "   $0 start dev              # Start bot in Docker with hot-reload"
            echo "   $0 start prod             # Start bot in Docker production mode"
            echo ""
            echo "   # For native development:"
            echo "   source .venv/bin/activate # Activate virtual environment"
            echo "   python3 run.py            # Discord bot"
            echo "   python3 universal_native_app.py   # Desktop app"
            echo ""
            echo "üìã Infrastructure Status:"
            echo "   $0 status       # Check infrastructure health"
            echo "   $0 stop         # Stop infrastructure"
            ;;
        *)
            print_error "Invalid mode: $mode"
            show_help
            exit 1
            ;;
    esac
}

stop_bot() {
    local mode="${1:-auto}"
    check_docker  # Ensure COMPOSE_CMD is set
    
    if [ "$mode" = "auto" ]; then
        # Auto-detect running compose setup by checking which containers are running
        if $COMPOSE_CMD ps -q 2>/dev/null | grep -q .; then
            # Check if prod compose is running
            if $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml ps -q 2>/dev/null | grep -q .; then
                mode="prod"
            # Check if dev compose is running
            elif $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml ps -q 2>/dev/null | grep -q .; then
                mode="dev"
            else
                mode="infrastructure"  # fallback to infrastructure mode
            fi
        else
            print_warning "No running containers detected. Stopping all compose configurations..."
            $COMPOSE_CMD down 2>/dev/null || true
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml down 2>/dev/null || true
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml down 2>/dev/null || true
            print_status "Services stopped!"
            return 0
        fi
    fi
    
    case $mode in
        "prod")
            echo "üõë Stopping production bot only..."
            echo "   ü§ñ Stopping bot container..."
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml stop whisperengine-bot 2>/dev/null || true
            echo "   üóÑÔ∏è Infrastructure services remain running"
            ;;
        "dev")
            echo "üõë Stopping development bot only..."
            echo "   ü§ñ Stopping development bot container..."
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml stop whisperengine-bot 2>/dev/null || true
            echo "   üóÑÔ∏è Infrastructure services remain running"
            ;;
        "infrastructure")
            echo "üõë Stopping infrastructure services..."
            echo "   üí° Note: Your native Discord bot (if running) will continue running"
            $COMPOSE_CMD down
            ;;
        "all")
            echo "üõë Stopping all services..."
            # Graceful shutdown: Bot first, then datastores
            echo "   ü§ñ Stopping bot..."
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml stop whisperengine-bot 2>/dev/null || true
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml stop whisperengine-bot 2>/dev/null || true
            echo "   üóÑÔ∏è Stopping datastores..."
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml down 2>/dev/null || true
            $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml down 2>/dev/null || true
            $COMPOSE_CMD down 2>/dev/null || true
            ;;
        *)
            print_error "Invalid mode: $mode"
            echo "Valid modes: prod, dev, infrastructure, all"
            exit 1
            ;;
    esac
    print_status "Services stopped!"
}

show_logs() {
    check_docker  # Ensure COMPOSE_CMD is set
    
    # Validate service name to prevent command injection
    local service="${1:-whisperengine-bot}"
    if [[ ! "$service" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Invalid service name: $service"
        print_warning "Valid service names contain only letters, numbers, underscores, and hyphens"
        return 1
    fi
    
    # Check if the service exists in the compose configuration
    # Auto-detect which compose configuration is running
    local compose_files=""
    if $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml ps -q 2>/dev/null | grep -q .; then
        compose_files="-f docker-compose.yml -f docker-compose.prod.yml"
    elif $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml ps -q 2>/dev/null | grep -q .; then
        compose_files="-f docker-compose.yml -f docker-compose.dev.yml"
    else
        compose_files=""  # Default to base compose only (infrastructure mode)
    fi
    
    if ! $COMPOSE_CMD $compose_files config --services 2>/dev/null | grep -q "^${service}$"; then
        print_error "Service '$service' not found in Docker Compose configuration"
        echo ""
        echo "Available services:"
        $COMPOSE_CMD $compose_files config --services 2>/dev/null | sed 's/^/  ‚Ä¢ /' || echo "  Unable to list services"
        echo ""
        echo "üí° Note: If you're running in infrastructure mode, only infrastructure services are available."
        echo "   For Discord bot logs, check your native Python process logs."
        return 1
    fi
    
    echo "üìã Viewing $service logs (Ctrl+C to exit)..."
    $COMPOSE_CMD $compose_files logs -f "$service"
}

show_status() {
    check_docker  # Ensure COMPOSE_CMD is set
    echo "üìä Container Status:"
    
    # Auto-detect which compose configuration is running
    local compose_files=""
    if $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml ps -q 2>/dev/null | grep -q .; then
        echo "   (Development configuration)"
        compose_files="-f docker-compose.yml -f docker-compose.dev.yml"
        $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml ps
    elif $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml ps -q 2>/dev/null | grep -q .; then
        echo "   (Production configuration)"
        compose_files="-f docker-compose.yml -f docker-compose.prod.yml"
        $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml ps
    else
        echo "   (Base configuration)"
        $COMPOSE_CMD ps
        return  # Skip health checks for base config
    fi
    
    echo ""
    echo "üè• Health Status:"
    
    # Check infrastructure health
    local healthy_count=0
    
    if $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml ps postgres 2>/dev/null | grep -q "healthy" || $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml ps postgres 2>/dev/null | grep -q "healthy"; then 
        echo "   ‚úÖ PostgreSQL: Healthy"
        ((healthy_count++))
    else
        echo "   ‚ùå PostgreSQL: Not healthy"
    fi
    
    if $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml ps redis 2>/dev/null | grep -q "healthy" || $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml ps redis 2>/dev/null | grep -q "healthy"; then 
        echo "   ‚úÖ Redis: Healthy"
        ((healthy_count++))
    else
        echo "   ‚ùå Redis: Not healthy"
    fi
    
    if $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml ps qdrant 2>/dev/null | grep -q "healthy" || $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml ps qdrant 2>/dev/null | grep -q "healthy"; then 
        echo "   ‚úÖ Qdrant: Healthy"
        ((healthy_count++))
    else
        echo "   ‚ùå Qdrant: Not healthy"
    fi
    
    # Check bot health using our health endpoint
    if curl -sf http://localhost:9090/health >/dev/null 2>&1; then
        echo "   ‚úÖ Bot: Healthy"
        ((healthy_count++))
        
        # Show additional bot info
        echo ""
        echo "ü§ñ Bot Health Details:"
        if command -v jq >/dev/null 2>&1; then
            curl -s http://localhost:9090/status 2>/dev/null | jq -r '
                "   Bot User: " + (.bot.user // "Unknown"),
                "   Guilds: " + (.bot.guilds_count | tostring),
                "   Latency: " + (.bot.latency_ms | tostring) + "ms",
                "   Ready: " + (.bot.is_ready | tostring)
            ' 2>/dev/null || echo "   (Health endpoint data available at http://localhost:9090/status)"
        else
            echo "   Health endpoint: http://localhost:9090/health"
            echo "   Status endpoint: http://localhost:9090/status"
            echo "   Install 'jq' for detailed health info display"
        fi
    else
        echo "   ‚ùå Bot: Not healthy or not responding"
    fi
    
    echo ""
    echo "üìà Overall Status: $healthy_count/5 services healthy"
    
    if [[ $healthy_count -eq 5 ]]; then
        print_status "All systems operational!"
    elif [[ $healthy_count -ge 4 ]]; then
        print_warning "Most services healthy, check any failed services above"
    else
        print_error "Multiple services unhealthy. Consider restarting: $0 restart-all"
    fi
}

restart_bot() {
    local mode="$1"
    
    # Require explicit mode selection
    if [[ -z "$mode" ]]; then
        print_error "Mode is required. Please specify: prod, dev, or infrastructure"
        echo ""
        echo "Usage: $0 restart <mode>"
        echo "  prod           - Restart production bot container"
        echo "  dev            - Restart development bot container with hot-reload"
        echo "  infrastructure - Restart infrastructure services only"
        echo ""
        echo "üí° For native development, restart your Python process manually."
        exit 1
    fi
    
    check_docker
    
    # Auto-detect which compose configuration is running
    local compose_files=""
    case $mode in
        "prod")
            compose_files="-f docker-compose.yml -f docker-compose.prod.yml"
            echo "üîÑ Restarting production bot container..."
            eval "$COMPOSE_CMD $compose_files restart whisperengine-bot"
            
            # Wait a moment for the container to be ready
            echo "‚è≥ Waiting for bot to restart..."
            sleep 3
            
            # Check if the bot container is running
            if eval "$COMPOSE_CMD $compose_files ps whisperengine-bot" | grep -q "Up"; then
                print_status "Bot container restarted successfully!"
            else
                print_warning "Bot container may still be starting. Check status with: $0 status"
            fi
            ;;
        "dev")
            compose_files="-f docker-compose.yml -f docker-compose.dev.yml"
            echo "üîÑ Restarting development bot container with hot-reload..."
            eval "$COMPOSE_CMD $compose_files restart whisperengine-bot"
            
            # Wait a moment for the container to be ready
            echo "‚è≥ Waiting for bot to restart..."
            sleep 3
            
            # Check if the bot container is running
            if eval "$COMPOSE_CMD $compose_files ps whisperengine-bot" | grep -q "Up"; then
                print_status "Development bot container restarted successfully!"
                echo "üîÑ Hot-reload is active - code changes will automatically restart the bot"
            else
                print_warning "Bot container may still be starting. Check status with: $0 status"
            fi
            ;;
        "infrastructure")
            echo "üîÑ Restarting infrastructure services..."
            $COMPOSE_CMD restart postgres redis qdrant
            
            echo "‚è≥ Waiting for services to restart..."
            sleep 5
            
            print_status "Infrastructure services restarted!"
            echo "üí° Your native Discord bot (if running) continues unchanged."
            ;;
        *)
            print_error "Invalid mode: $mode"
            echo "Valid modes: prod, dev, infrastructure"
            exit 1
            ;;
    esac
}

restart_all() {
    local mode="$1"
    
    # Require explicit mode selection
    if [[ -z "$mode" ]]; then
        print_error "Mode is required. Please specify: prod, dev, or infrastructure"
        echo ""
        echo "Usage: $0 restart-all <mode>"
        echo "üí° This preserves all data (memories, embeddings, relationships)"
        exit 1
    fi
    
    echo "üîÑ Restarting ALL services in $mode mode (preserving data)..."
    stop_bot "$mode"
    sleep 2
    start_bot "$mode"
}

restart_full() {
    # Alias for restart_all with clearer name
    restart_all "$1"
}

restart_clean() {
    local mode="$1"
    
    # Require explicit mode selection
    if [[ -z "$mode" ]]; then
        print_error "Mode is required. Please specify: prod, dev, or infrastructure"
        echo ""
        echo "Usage: $0 restart-clean <mode>"
        echo "üí° This clears cache but preserves memories and embeddings"
        exit 1
    fi
    
    echo "üîÑ Restarting ALL services in $mode mode (clearing cache)..."
    
    # Stop services
    stop_bot "$mode"
    
    # Clear Redis cache specifically
    echo "üßπ Clearing Redis cache..."
    clear_redis_cache "$mode"
    
    sleep 2
    start_bot "$mode"
    
    print_status "Services restarted with cache cleared!"
    echo "üíæ Persistent data (memories, embeddings) preserved"
}

clear_cache() {
    local mode="${1:-auto}"
    
    echo "üßπ Clearing Redis cache in $mode mode..."
    clear_redis_cache "$mode"
    print_status "Cache cleared! Bot will rebuild conversations from persistent memory."
}

clear_redis_cache() {
    local mode="$1"
    
    # Try to clear Redis if it's running (more reliable check)
    if docker exec whisperengine-redis redis-cli PING >/dev/null 2>&1; then
        echo "   üóëÔ∏è Flushing Redis cache..."
        docker exec whisperengine-redis redis-cli FLUSHALL
        echo "   ‚úÖ Redis cache cleared successfully"
    else
        echo "   ‚ö†Ô∏è Redis container not running, cache will be empty on next start"
    fi
}

reset_data() {
    local mode="$1"
    
    # Require explicit mode selection
    if [[ -z "$mode" ]]; then
        print_error "Mode is required. Please specify: prod, dev, or infrastructure"
        echo ""
        echo "Usage: $0 reset-data <mode>"
        exit 1
    fi
    
    # Safety confirmation
    echo "‚ö†Ô∏è  DANGER: This will permanently delete ALL data including:"
    echo "   ‚Ä¢ User memories and conversation history"
    echo "   ‚Ä¢ Vector embeddings and semantic search index"
    echo "   ‚Ä¢ Graph relationships and personality profiles"
    echo "   ‚Ä¢ All cached data"
    echo ""
    echo "üî¥ This action CANNOT be undone!"
    echo ""
    read -p "Type 'DELETE ALL DATA' to confirm: " confirmation
    
    if [[ "$confirmation" != "DELETE ALL DATA" ]]; then
        print_status "Data reset cancelled - no changes made"
        return 0
    fi
    
    echo ""
    echo "üî• Stopping services and deleting ALL data volumes..."
    
    # Stop everything first
    stop_bot "$mode"
    
    # Get compose files for the mode
    local compose_files=""
    case $mode in
        "prod")
            compose_files="-f docker-compose.yml -f docker-compose.prod.yml"
            ;;
        "dev")
            compose_files="-f docker-compose.yml -f docker-compose.dev.yml"
            ;;
        "infrastructure")
            compose_files=""
            ;;
        *)
            print_error "Invalid mode: $mode"
            exit 1
            ;;
    esac
    
    # Remove containers AND volumes
    echo "üí• Removing containers and volumes..."
    eval "$COMPOSE_CMD $compose_files down -v --remove-orphans"
    
    # Also remove any named volumes that might persist
    echo "üóëÔ∏è Removing named volumes..."
    docker volume rm whisperengine-redis 2>/dev/null || true
    docker volume rm whisperengine-postgres 2>/dev/null || true
    docker volume rm whisperengine-qdrant 2>/dev/null || true
    docker volume rm whisperengine-data 2>/dev/null || true
    docker volume rm whisperengine-backups 2>/dev/null || true
    
    print_status "ALL data volumes deleted!"
    echo ""
    echo "üöÄ Start the bot again with: $0 start $mode"
    echo "üí° The bot will initialize with fresh databases and no memory of previous conversations"
}

cleanup_containers() {
    check_docker  # Ensure COMPOSE_CMD is set
    
    echo "üßπ Cleaning up orphaned containers and volumes..."
    
    # Stop and remove all containers related to this project
    echo "üõë Stopping all project containers..."
    $COMPOSE_CMD down --remove-orphans 2>/dev/null || true
    $COMPOSE_CMD -f docker-compose.yml -f docker-compose.dev.yml down --remove-orphans 2>/dev/null || true
    $COMPOSE_CMD -f docker-compose.yml -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true
    
    # Remove any orphaned containers with old custom-bot or whisperengine-bot prefix
    echo "üóëÔ∏è Removing orphaned containers..."
    docker ps -a --format "table {{.Names}}" | grep -E "^(custom-bot|whisperengine)" | xargs -r docker rm -f 2>/dev/null || true
    
    # Clean up unused volumes (but keep data volumes)
    echo "üíæ Cleaning unused Docker resources..."
    docker system prune -f --volumes 2>/dev/null || true
    
    print_status "Cleanup completed!"
    echo "üí° Note: Data volumes (postgres, redis, qdrant) are preserved"
    echo "   To remove all data, use: docker volume prune"
}

# Backup operations
handle_backup() {
    # Check if backup script exists
    local backup_script="./scripts/backup.sh"
    if [[ ! -f "$backup_script" ]]; then
        print_error "Backup script not found: $backup_script"
        echo "The backup functionality requires the backup script to be present."
        exit 1
    fi
    
    # Make sure backup script is executable
    if [[ ! -x "$backup_script" ]]; then
        chmod +x "$backup_script"
    fi
    
    # Pass all arguments to the backup script
    local backup_command="${1:-help}"
    shift || true  # Remove first argument, keep the rest
    
    case "$backup_command" in
        "create"|"list"|"restore"|"cleanup"|"help")
            exec "$backup_script" "$backup_command" "$@"
            ;;
        *)
            print_error "Invalid backup command: $backup_command"
            echo "Valid backup commands: create, list, restore, cleanup, help"
            echo "Use '$0 backup help' for detailed backup help"
            exit 1
            ;;
    esac
}

# Main command handling
case "${1:-help}" in
    "start")
        start_bot "${2:-}"
        ;;
    "stop")
        stop_bot "${2:-auto}"
        ;;
    "logs")
        # Validate second argument if provided
        if [[ -n "${2:-}" ]] && [[ ! "${2:-}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            print_error "Invalid service name: ${2:-}"
            exit 1
        fi
        show_logs "${2:-whisperengine-bot}"
        ;;
    "status")
        show_status
        ;;
    "restart")
        restart_bot "${2:-}"
        ;;
    "restart-all")
        restart_all "${2:-}"
        ;;
    "restart-full")
        restart_full "${2:-}"
        ;;
    "restart-clean")
        restart_clean "${2:-}"
        ;;
    "clear-cache")
        clear_cache "${2:-}"
        ;;
    "reset-data")
        reset_data "${2:-}"
        ;;
    "cleanup")
        cleanup_containers
        ;;
    "backup")
        shift  # Remove 'backup' from arguments
        handle_backup "$@"
        ;;
    "import-chatgpt")
        if [[ $# -lt 3 ]]; then
            print_error "Usage: $0 import-chatgpt <conversations.json> <discord-user-id> [options]"
            echo ""
            echo "Examples:"
            echo "  $0 import-chatgpt ~/Downloads/conversations.json 672814231002939413"
            echo "  $0 import-chatgpt conversations.json 672814231002939413 --verbose"
            echo "  $0 import-chatgpt conversations.json 672814231002939413 --dry-run"
            echo ""
            echo "Options:"
            echo "  --verbose     Show detailed progress"
            echo "  --dry-run     Test without importing"
            echo "  --start-date  Only import after date (YYYY-MM-DD)"
            echo "  --end-date    Only import before date (YYYY-MM-DD)"
            echo "  --min-messages Skip conversations shorter than N messages"
            exit 1
        fi
        
        conversations_file="$2"
        user_id="$3"
        shift 3  # Remove the command and required arguments
        
        # Validate file exists
        if [[ ! -f "$conversations_file" ]]; then
            print_error "File not found: $conversations_file"
            echo "Make sure the path to your conversations.json file is correct."
            exit 1
        fi
        
        # Validate user ID format (Discord user IDs are 17-19 digits)
        if [[ ! "$user_id" =~ ^[0-9]{17,19}$ ]]; then
            print_error "Invalid Discord User ID format: $user_id"
            echo "Discord User IDs should be 17-19 digit numbers."
            echo "Get your ID: Discord Settings ‚Üí Advanced ‚Üí Developer Mode ‚Üí Right-click username ‚Üí Copy User ID"
            exit 1
        fi
        
        print_status "Starting ChatGPT import..."
        echo "üìÅ File: $conversations_file"
        echo "üë§ User ID: $user_id"
        echo "‚öôÔ∏è  Options: $*"
        echo ""
        
        # Check if services are running, start if needed
        check_docker
        check_env
        
        # Detect mode and ensure services are running
        mode="auto"
        if [[ -f "docker-compose.override.yml" ]]; then
            mode="dev"
        else
            mode="prod"
        fi
        
        # Ensure bot services are running
        if ! $COMPOSE_CMD ps whisperengine-bot | grep -q "Up"; then
            print_warning "WhisperEngine bot is not running. Starting services..."
            start_bot "$mode"
            sleep 10  # Give services time to fully start
        fi
        
        # Run the import using Docker exec
        print_status "Running ChatGPT import in container..."
        
        # Convert file path to absolute path for Docker mounting
        abs_conversations_file=$(realpath "$conversations_file")
        container_file="/app/conversations_import.json"
        
        # Copy file into container app directory (appuser should have access)
        docker cp "$abs_conversations_file" whisperengine-bot:"$container_file"
        
        # Change file permissions to be readable by appuser
        docker exec --user root whisperengine-bot chmod 644 "$container_file"
        
        # Run the import command with all passed options
        if docker exec whisperengine-bot python scripts/chatgpt_import/import_chatgpt.py \
            --file "$container_file" \
            --user-id "$user_id" \
            "$@"; then
            print_status "ChatGPT import completed successfully!"
            echo ""
            echo "üß† Your ChatGPT conversations are now part of WhisperEngine's memory."
            echo "üîç Test it: Ask WhisperEngine about something you discussed in ChatGPT."
            echo "üìä Check stats with Discord commands like: !memory user stats"
        else
            print_error "ChatGPT import failed. Check the logs above for details."
            echo ""
            echo "üí° Troubleshooting tips:"
            echo "  ‚Ä¢ Make sure the file is a valid ChatGPT export (conversations.json)"
            echo "  ‚Ä¢ Verify your Discord User ID is correct"
            echo "  ‚Ä¢ Check that WhisperEngine services are healthy: $0 status"
            echo "  ‚Ä¢ Try a dry run first: $0 import-chatgpt file.json user-id --dry-run"
            exit 1
        fi
        
        # Clean up temporary file
        docker exec whisperengine-bot rm -f "$container_file" 2>/dev/null || true
        ;;
    "build-push")
        shift  # Remove 'build-push' from arguments
        # Forward all remaining arguments to the Docker build script
        exec "$(dirname "$0")/scripts/docker-build-push.sh" "$@"
        ;;
    "help"|*)
        show_help
        ;;
esac
