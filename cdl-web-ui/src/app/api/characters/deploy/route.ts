import { NextRequest, NextResponse } from 'next/server'
import fs from 'fs/promises'
import path from 'path'
import { exec } from 'child_process'
import { promisify } from 'util'

const execAsync = promisify(exec)

// Deploy a character as an active WhisperEngine bot
export async function POST(request: NextRequest) {
  try {
    const { characterId, deploymentConfig } = await request.json()

    if (!characterId) {
      return NextResponse.json(
        { error: 'Character ID is required' },
        { status: 400 }
      )
    }

    // Get character from database
    const { getCharacterById } = await import('@/lib/db')
    const character = await getCharacterById(parseInt(characterId))

    if (!character) {
      return NextResponse.json(
        { error: 'Character not found' },
        { status: 404 }
      )
    }

    // Generate environment file for this character
    const botName = character.normalized_name || character.name.toLowerCase().replace(/[^a-z0-9]/g, '_')
    const envFileName = `.env.${botName}`
    const envFilePath = path.join(process.cwd(), '..', envFileName)

    // Load current system config
    const mainEnvPath = path.join(process.cwd(), '../.env')
    let systemConfig: Record<string, string> = {}
    
    try {
      const envContent = await fs.readFile(mainEnvPath, 'utf-8')
      const lines = envContent.split('\n')
      for (const line of lines) {
        const trimmed = line.trim()
        if (trimmed && !trimmed.startsWith('#')) {
          const [key, ...valueParts] = trimmed.split('=')
          const value = valueParts.join('=').replace(/^["']|["']$/g, '')
          systemConfig[key] = value
        }
      }
    } catch (error) {
      console.error('Error reading system config:', error)
    }

    // Generate character-specific environment
    const healthCheckPort = deploymentConfig?.healthCheckPort || (9090 + parseInt(characterId))
    const collectionName = `whisperengine_memory_${botName}`

    const characterEnv = [
      `# ${character.name} Character Configuration`,
      `# Generated by CDL Web UI`,
      '',
      '# Character Identity',
      `DISCORD_BOT_NAME=${botName}`,
      `CHARACTER_NAME=${botName}`,
      `HEALTH_CHECK_PORT=${healthCheckPort}`,
      '',
      '# LLM Configuration (inherited from system)',
      `LLM_CLIENT_TYPE=${systemConfig.LLM_CLIENT_TYPE || 'openrouter'}`,
      `LLM_CHAT_API_URL=${systemConfig.LLM_CHAT_API_URL || 'https://openrouter.ai/api/v1'}`,
      `LLM_CHAT_MODEL=${systemConfig.LLM_CHAT_MODEL || 'anthropic/claude-3-haiku'}`,
      `LLM_CHAT_API_KEY=${systemConfig.LLM_CHAT_API_KEY || ''}`,
      '',
      '# Discord Configuration (optional)',
      `DISCORD_BOT_TOKEN=${deploymentConfig?.discordToken || ''}`,
      `ENABLE_DISCORD=${deploymentConfig?.enableDiscord ? 'true' : 'false'}`,
      '',
      '# Memory Configuration',
      `MEMORY_SYSTEM_TYPE=${systemConfig.MEMORY_SYSTEM_TYPE || 'vector'}`,
      `QDRANT_COLLECTION_NAME=${collectionName}`,
      `ENABLE_CHARACTER_INTELLIGENCE=true`,
      `ENABLE_EMOTIONAL_INTELLIGENCE=true`,
      '',
      '# Database Configuration (inherited from system)',
      `POSTGRES_HOST=${systemConfig.POSTGRES_HOST || 'postgres'}`,
      `POSTGRES_PORT=${systemConfig.POSTGRES_PORT || '5432'}`,
      `POSTGRES_USER=${systemConfig.POSTGRES_USER || 'whisperengine'}`,
      `POSTGRES_PASSWORD=${systemConfig.POSTGRES_PASSWORD || 'whisperengine_password'}`,
      `POSTGRES_DB=${systemConfig.POSTGRES_DB || 'whisperengine'}`,
      '',
      '# Vector Database Configuration',
      `QDRANT_HOST=${systemConfig.QDRANT_HOST || 'qdrant'}`,
      `QDRANT_PORT=${systemConfig.QDRANT_PORT || '6333'}`,
      ''
    ].join('\n')

    // Write character environment file
    await fs.writeFile(envFilePath, characterEnv, 'utf-8')

    // Update character as active in database
    const { updateCharacterActiveStatus } = await import('@/lib/db')
    await updateCharacterActiveStatus(parseInt(characterId), true)

    // Regenerate multi-bot configuration if the script exists
    const scriptPath = path.join(process.cwd(), '../scripts/generate_multi_bot_config.py')
    try {
      await fs.access(scriptPath)
      const workingDir = path.join(process.cwd(), '..')
      await execAsync('python scripts/generate_multi_bot_config.py', { cwd: workingDir })
      console.log('Multi-bot configuration regenerated')
    } catch (error) {
      console.log('Multi-bot script not found or failed to run:', error)
    }

    return NextResponse.json({
      success: true,
      message: `Character "${character.name}" deployed successfully`,
      deployment: {
        botName,
        envFile: envFileName,
        healthCheckPort,
        collectionName,
        apiEndpoint: `http://localhost:${healthCheckPort}/api/chat`
      }
    })
  } catch (error) {
    console.error('Error deploying character:', error)
    return NextResponse.json(
      { error: 'Failed to deploy character' },
      { status: 500 }
    )
  }
}

// Get deployment status for characters
export async function GET() {
  try {
    // Check which characters have environment files
    const parentDir = path.join(process.cwd(), '..')
    const files = await fs.readdir(parentDir)
    const envFiles = files.filter(file => file.startsWith('.env.') && file !== '.env.template')
    
    const deployments = []
    
    for (const envFile of envFiles) {
      const botName = envFile.replace('.env.', '')
      const envPath = path.join(parentDir, envFile)
      
      try {
        const envContent = await fs.readFile(envPath, 'utf-8')
        const lines = envContent.split('\n')
        
        let healthCheckPort = '9090'
        let characterName = botName
        
        for (const line of lines) {
          const trimmed = line.trim()
          if (trimmed.startsWith('HEALTH_CHECK_PORT=')) {
            healthCheckPort = trimmed.split('=')[1]
          }
          if (trimmed.startsWith('CHARACTER_NAME=')) {
            characterName = trimmed.split('=')[1]
          }
        }
        
        // Test if service is running
        let isRunning = false
        try {
          const response = await fetch(`http://localhost:${healthCheckPort}/health`, {
            signal: AbortSignal.timeout(2000)
          })
          isRunning = response.ok
        } catch {
          isRunning = false
        }
        
        deployments.push({
          botName,
          characterName,
          envFile,
          healthCheckPort,
          apiEndpoint: `http://localhost:${healthCheckPort}/api/chat`,
          isRunning
        })
      } catch (error) {
        console.error(`Error reading ${envFile}:`, error)
      }
    }

    return NextResponse.json({
      success: true,
      deployments
    })
  } catch (error) {
    console.error('Error getting deployment status:', error)
    return NextResponse.json(
      { error: 'Failed to get deployment status' },
      { status: 500 }
    )
  }
}